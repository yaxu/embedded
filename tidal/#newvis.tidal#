import qualified Graphics.Rendering.Cairo as C 
import Data.Colour
import Data.Colour.Names
import Data.Colour.SRGB
import Control.Applicative
import Sound.Tidal.Parse
import Sound.Tidal.Pattern
import Sound.Tidal.Utils
import Data.Ratio
import Data.Maybe


let arrangeEvents [] = []
    arrangeEvents (e:es) = addEvent e (arrangeEvents es)
    fits e es = null $ filter (id) $ map (\e' -> isJust $ subArc (snd' e) (snd' e')) es
    addEvent e [] = [[e]]
    addEvent e (level:levels) | fits e level = (e:level):levels
                              | otherwise = level:(addEvent e levels)

let v sf fn (x,y) levels =
      sf fn x y $ \surf -> do
        C.renderWith surf $ do
          C.save
          C.scale x (y / (fromIntegral $ length levels))
          C.setOperator C.OperatorOver
          -- C.setSourceRGB 0 0 0
          -- C.rectangle 0 0 1 1
          --C.fill
          mapM_ (renderLevel (length levels)) $ enumerate levels
          C.restore
    renderLevel total (n, level) = do C.save
                                      mapM_ drawEvent level
                                      C.restore
      where height = 1
            drawEvent (_, (s,e), c) = 
              do let (RGB r g b) = toSRGB c
                 C.setSourceRGBA 0.6 0.6 0.6 1
                 C.rectangle (x+lgap+w) (y+half -(lineH/2.0) - border) lineW lineH
                 C.fill
                 -- C.stroke
                 C.setSourceRGBA r g b 1
                 -- C.rectangle x y w h
                 C.
                 C.fill
                 -- C.stroke
                   where x = (fromRational s)
                         y = (fromIntegral n) * height + border
                         w = (fromRational ratio) - (border * ratio * 2)
                         lineW = (fromRational (e-s)) - lgap - rgap - w
                         lineH = 0.03
                         lgap = 0.002
                         rgap = 0.01
                         border = 0.1
                         h = height - border*2
                         half = height / 2
                         quarter = height / 4
    vPDF = v C.withPDFSurface
    totalWidth = 600 :: Double
    ratio = 1/20
    vis name pat = do v (C.withSVGSurface) (name ++ ".svg") (totalWidth,((totalWidth * ratio)*(fromIntegral $ length levels))) levels
                      rawSystem "/home/alex/Dropbox/bin/fixsvg.pl" [name ++ ".svg"]
                      rawSystem "convert" [name ++ ".svg", name ++ ".pdf"]
                      return ()
                        where levels = arrangeEvents (arc pat (0,1))

  in
vis "test" $ density 4 "[red blue, green orange, purple green tomato]"

:t totalWidth

:t C.polygon

fits ((0,1),(0,1),"b")  [((0,1),(0,1), "a") :: Event String]

vPDF = v C.withPDFSurface
vSVG = v C.withSVGSurface


vLines sf fn (x,y) pat cyclesPerLine nLines = 
  sf fn x y $ \surf -> do
    C.renderWith surf $ do 
      C.save 
      C.scale x (y / (fromIntegral nLines))
      C.setOperator C.OperatorOver
      C.setSourceRGB 0 0 0 
      C.rectangle 0 0 1 1
      C.fill
      mapM_ (\x -> do C.save
                      C.translate 0 (fromIntegral x)
                      drawLine ((cyclesPerLine * (fromIntegral x)) `rotR` pat)
                      C.restore
            ) [0 .. (nLines - 1)]
      C.restore 
  where drawLine p = mapM_ renderEvent (events (_density cyclesPerLine p))


renderEvent (_, (s,e), (cs)) = do C.save
                                  drawBlocks cs 0
                                  C.restore
   where height = 1/(fromIntegral $ length cs)
         drawBlocks [] _ = return ()
         drawBlocks (c:cs) n = do let (RGB r g b) = toSRGB c
                                  C.setSourceRGBA r g b 1
                                  C.rectangle x y h h
                                  C.fill
                                  C.stroke
                                  C.setSourceRGBA 1 1 1 1
                                  C.rectangle x y w h
                                  C.fill
                                  C.stroke
                                  drawBlocks cs (n+1)
           where x = (fromRational s)
                 y = (fromIntegral n) * height
                 w = (fromRational (e-s))
                 h = height

events "a b" :: Pattern String
  
events pat = (map (mapSnd' (\(s,e) -> ((s - (ticks/2))/speed,(e - (ticks/2))/speed))) $ arc (segment pat) ((ticks/2), (ticks/2)+speed))
  where speed = 1
ticks = 0
--pat = p "[red blue green,orange purple]" :: Sequence ColourD
:t C.path
