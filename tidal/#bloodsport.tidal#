d1 $
  struct "[x x] x"
  $ slow 2 $ n (run 8)
  # sound "bsperc"
  # unit "c"
  # speed "4"

d1 $ n (run 1) # sound "bsbass"
  # unit "c"
  # gain "0.9"

d2 $ every 4 (chop 4) $ sound "{bshihat:2 bskick [{bsperc:5 bsperc:5}%1 bskick] ~, ~  ~ bsperc}"
  # gain "1"

d4 $ (struct "[x x . [x x x . x x . ~ x . x*4]/4]" $ n "0 1 2 3" # sound "bskick")
  # speed (scale 1 2 sine1)

d3 $ slow 2 $ rev $ loopAt 8 $ slowspread (striate) [8,16] $ sound "bsvocals:10 ~"
  |*| speed "[1,0.9]"
  # gain "0.8"
  # vowel "i"


d1 $ ur' 16 "[~ hook ! !, kick:in kick ! !, perc]"
  $ [("hook",
      loopAt 2 $ chop 16 $ s "bsbass"
     ),
     ("kick",
      n (off 0.125 (+1) $ off 0.25 (+2) "0(3,8)") # s "bskick"
      # crush (every 4 (subtract 3) 7)
     ),
     ("perc",
      n "<0 0 1 2(3,8)>"
      # s "bsperc"
      # cutoff (3000 * (slow 2 tri1) + 1000)
      # resonance 0.3
      # orbit 1 # room 0.5
      )
    ]

import Data.Maybe
import Sound.Tidal.Utils

let ur' :: Time -> Pattern String -> [(String, Pattern a)] -> [(String, Pattern a -> Pattern a)] -> Pattern a
    ur' t outer_p ps fs = slow t $ unwrap $ adjust <$> (timedValues $ (getPat . split) <$> outer_p)
      where split s = wordsBy (==':') s
            getPat (s:xs) = (match s, transform xs)
            match s = fromMaybe silence $ lookup s ps'
            ps' = map (fmap (density t)) ps
            adjust (a, (p, f)) = f a p
            transform (x:_) a = transform' x a
            transform _ _ = id
            transform' "in" (s,e) p = twiddle (fadeIn) (s,e) p
            transform' "out" (s,e) p = twiddle (fadeOut) (s,e) p
            transform' str (s,e) p = s ~> (inside (1/(e-s)) (matchF str) p)
            matchF str = fromMaybe id $ lookup str fs
            transform' _ _ p = p
            twiddle f (s,e) p = s ~> (f (e-s) p)

instance Integral a => Integral (Pattern a) where
  toInteger p = toInteger $ thd' $ head $ arc p (0,1)

    
d1 $ sound "bd sn"
  # speed 


