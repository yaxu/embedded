d1 $ slow 2 $ jux rev $ sometimes (|+| n "-12") $ slow 4 $ n (offadd (1/16) 12 $ offadd 0.125 7 $ struct "x(3,8) x*2 x*3 x*4]" "[[f8 a8 c8 e8] ! ! ! [c8 d8 e8 g8] ! ! !]/8") # s "xx"
  # cutoff "3000"
  # resonance "0.3"
  # room "0"
  # size "1"
  # end "0.4"
  -- # size "0.5" |*| speed "0.25"
  -- # room "0.65"
  # gain "0.85"

--
let a = every 2 (slow 1.5) $ gap 16 $ jux (0.25 <~) $ (off 0.125 (|+| n "7") $ slow 2 $ s (substruct "x [~ x]" $ struct "[x*2 x*3 x*4]/3" ("xx")))
        # n (slow 4 "d7 e7 f7 g7")
        # resonance "0.1"
        # cutoff (slow 4 $ scale 1000 5000 saw1)
        # speed "[4,4.05]"
        # gain "0.8"
    b = juxBy 0.5 (2 <~) $ slowspread (loopAt) [2,1,4,4] $ chop 12 $ sound "shakedown"
        # gain "1.1"
    c = substruct "x/2 [~ x/4]" $ n (offadd 0.25 12 $ offadd 0.125 7 $ slow 4 $ "f7(3,8) a7(3,8) c7(3,8) e8*2") # s "xx"
        # cutoff (slow 4 $ rev $ scale 1000 7000 saw1)
        # resonance "0.3"
        # gain "0.8"
    d = every 2 (within (0,0.25) (rev . density 2)) $ juxBy 0.6 rev $ loopAt 4 $ chop 16 $ sound "shakedown"
        # shape "0.6"

import Sound.Tidal.Utils

let repattern t p ps = slow t $ unwrap $ ((map (density t) ps) !!!) <$> p

let (pat, pat_p) = pS "pat" Nothing
    (tx, tx_p) = pS "tx" Nothing
    patx = grp [pat_p, tx_p]

let ur t p ps = (getPat . split) <$> p
      where split s = wordsBy (==':') s
            getPat (n:xs) = (transform xs) (ps' !!! read n)
            ps' = map density t ps
            transform (x:[]) = transform' x
            transform _ = id



grp :: [Param] -> Pattern String -> ParamPattern
grp [] _ = silence
grp params p = (fmap lookupPattern p)
  where lookupPattern :: String -> ParamMap
        lookupPattern s = Map.fromList $ map (\(param,s') -> toPV param s') $ zip params $ (split s)
        split s = wordsBy (==':') s
        toPV :: Param -> String -> (Param, Value)
        toPV param@(S _ _) s = (param, (VS s))
        toPV param@(F _ _) s = (param, (VF $ read s))
        toPV param@(I _ _) s = (param, (VI $ read s))


((\(VS s) -> s) . fromJust . Data.Map.lookup s_p) <$> (sound "bd" # n "0")

let repattern t p ps = slow t $ unwrap $ ((map (density t) ps) !!!) <$> p


let a = interlace (smash 8 [1,2,1,4] $ every 2 (density 2) $ jux (brak) $ whenmod 4 2 (density 2) $ slow 2 $ sound (pick <$> "future*8" <*> (slow 4 $ run 32))
                   |+| speed ((+1) <$>sine1))
                  (sound "~ bleep:9"
                   |+| speed (slow 8 sine1))
    b = slow 2 $ every 3 (slow 2) $ every 4 (density 2) $ superimpose (iter 4) $ jux (every 2 rev) $ sound "bd ~ sn*16 ~ bd*8 ~ sn*6 ~"
        |+| speed "2"
        |+| vowel "a"
    c = (spread' (striate' 4) ((+0.2) <$> slow 8 sine1)) $ jux rev $ sound (samples "[latibro*6,bd]/2" "0 7 4") |+| speed "[1 2 1.5]/4"
    in
d1 $ repattern 16 "[0 [1 0], 2 ! ! ~]*4 [0, ~ 1]" $ [a,b,c]

