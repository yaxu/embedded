d1 $ slow 2 $ jux rev $ sometimes (|+| n "-12") $ slow 4 $ n (offadd (1/16) 12 $ offadd 0.125 7 $ struct "x(3,8) x*2 x*3 x*4]" "[[f8 a8 c8 e8] ! ! ! [c8 d8 e8 g8] ! ! !]/8") # s "xx"
  # cutoff "3000"
  # resonance "0.3"
  # room "0"
  # size "1"
  # end "0.4"
  -- # size "0.5" |*| speed "0.25"
  -- # room "0.65"
  # gain "0.85"

--
let a = every 2 (slow 1.5) $ gap 16 $ jux (0.25 <~) $ (off 0.125 (|+| n "7") $ slow 2 $ s (substruct "x [~ x]" $ struct "[x*2 x*3 x*4]/3" ("xx")))
        # n (slow 4 "d7 e7 f7 g7")
        # resonance "0.1"
        # cutoff (slow 4 $ scale 1000 5000 saw1)
        # speed "[4,4.05]"
        # gain "0.8"
    b = juxBy 0.5 (2 <~) $ slowspread (loopAt) [2,1,4,4] $ chop 12 $ sound "shakedown"
        # gain "1.1"
    c = substruct "x/2 [~ x/4]" $ n (offadd 0.25 12 $ offadd 0.125 7 $ slow 4 $ "f7(3,8) a7(3,8) c7(3,8) e8*2") # s "xx"
        # cutoff (slow 4 $ rev $ scale 1000 7000 saw1)
        # resonance "0.3"
        # gain "0.8"
    d = every 2 (within (0,0.25) (rev . density 2)) $ juxBy 0.6 rev $ loopAt 4 $ chop 16 $ sound "shakedown"
        # shape "0.6"

import Sound.Tidal.Utils

let repattern t p ps = slow t $ unwrap $ ((map (density t) ps) !!!) <$> p

let (pat, pat_p) = pS "pat" Nothing
    (tx, tx_p) = pS "tx" Nothing
    patx = grp [pat_p, tx_p]


let annotateTime p = 


((\(VS s) -> s) . fromJust . Data.Map.lookup s_p) <$> (sound "bd" # n "0")

let repattern t p ps = slow t $ unwrap $ ((map (density t) ps) !!!) <$> p


let a = interlace (smash 8 [1,2,1,4] $ every 2 (density 2) $ jux (brak) $ whenmod 4 2 (density 2) $ slow 2 $ sound (pick <$> "future*8" <*> (slow 4 $ run 32))
                   |+| speed ((+1) <$>sine1))
                  (sound "~ bleep:9"
                   |+| speed (slow 8 sine1))
    b = slow 2 $ every 3 (slow 2) $ every 4 (density 2) $ superimpose (iter 4) $ jux (every 2 rev) $ sound "bd ~ sn*16 ~ bd*8 ~ sn*6 ~"
        |+| speed "2"
        |+| vowel "a"
    c = (spread' (striate' 4) ((+0.2) <$> slow 8 sine1)) $ jux rev $ sound (samples "[latibro*6,bd]/2" "0 7 4") |+| speed "[1 2 1.5]/4"
    in
d1 $ ur 32 "2:in 3:in 4:in" $ [a,b,c]

hush

let withEvent :: (Event a -> Event b) -> Pattern a -> Pattern b
    withEvent f p = Pattern $ \a -> map f $ arc p a
    timedValues :: Pattern a -> Pattern (Arc, a)
    timedValues = withEvent (\(a,a',v) -> (a,a',(a,v)))
    ur :: Time -> Pattern String -> [Pattern a] -> Pattern a
    ur t outer_p ps = slow t $ unwrap $ adjust <$> (timedValues $ (getPat . split) <$> outer_p)
      where split s = wordsBy (==':') s
            getPat (n:xs) = (ps' !!! read n, transform xs)
            ps' = map (density t) ps
            transform (x:_) a = transform' x a
            transform _ _ = id
            transform' "in" (s,e) p = (traceShow (s*t) s*t) <~ (fadeIn (e*t - s*t) (bug p))
            -- transform' "out" = adjust (fadeOut 1)
            transform' _ _ p = p
            adjust (a, (p, f)) = f a p
            -- adjust f p = (\((s,e), v) -> slow (e-s) $ s ~> (f (s <~ density (e-s) v))) <$> timedValues p



d1 $ ur 1 "0:in 1" [sound "bd*4", sound "sn*4"]

let bug p = Pattern $ \a -> arc p (trace ("bug: " ++ show a) a)

0               1               2
012345678901234567890123456789012

:t ur

import Debug.Trace
import Sound.Tidal.Utils

arc (timedValues ("a b" :: Pattern String)) (4,50)
